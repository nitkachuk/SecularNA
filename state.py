import unicodedata
import re 

import os
import datetime

import sys
from replacements import doReplacements 

from telegram import Bot
from g4f.client import Client

import random


bot_token = os.getenv('TELEGRAM_TOKEN')
bot = Bot(token=bot_token)
client = Client()

channelBook = '@SecularNA'
channelBill = '@BillSpeaks'

attempts = 0


def has_glyphs( text ):
    for char in text:
        if unicodedata.category(char) == 'Lo':
            return True
    return False

def has_latins( text ):
    latins_count = len(re.findall(r'[a-zA-Z]', text))
    #total_count = len(text)
    
    return latins_count > 10
    

def escape_markdown_v2(text, plus_underline = 0):
    escape_chars = [  '[', ']', '(', ')', '~', '‚ìÉ', '>', '#', '+', '-', 
                      '=', '|', '{', '}', '.', ',', '!', '?', '\\', '""'  ]
    if plus_underline:
        escape_chars += [ '_' ]
    
    for char in escape_chars:
        pattern = re.escape(char)
        
        if char == '\\':
            replacement = '\\\\'
        else:
            replacement = '\\' + char
        text = re.sub(pattern, replacement, text)

    text = text.replace('\\\\', '\\')
    return text


def escape_system_text( text, role_system='' ):
    text = text.replace( '_{"code":200,"status":true,"model":"gpt-3.5-turbo","gpt":"', '')
    text = text.replace( '","original":null}', '')

    text = text.replace(role_system, '')    
    text = text.replace('Assistant:', '')
    text = text.replace('assistant:', '')
    text = text.replace('–ö–æ–Ω–µ—Ü', '')
    text = text.replace('–∫–æ–Ω–µ—Ü', '')

    text = text.replace('–¢–æ–ª—å–∫–æ —Å–µ–≥–æ–¥–Ω—è: ', '')
    text = text.replace('–¢–û–õ–¨–ö–û –°–ï–ì–û–î–ù–Ø: ', '')
    return text


def escapeUnderline( text ):
    while '_' in text or '__' in text:
        text = text.replace('_', '').replace('__', '')
    return text


def readTheBook( clean = 0 ):
    # —á–∞—Å—ã –∑–∞–ø—É—Å–∫–∞ —Å–∫—Ä–∏–ø—Ç–∞ –Ω–∞ –≥–∏—Ç—Ö–∞–±–µ
    send_hour = 17
    send_minute = 0
    
    current_hour = datetime.datetime.now().hour
    current_minute = datetime.datetime.now().minute

    if current_hour > send_hour or (current_hour == send_hour and current_minute >= send_minute):
        today = datetime.date.today() + datetime.timedelta(days=1)
    else:
        today = datetime.date.today()

    current_day = today.day
    current_month = today.month

    folder_path = 'book'

    month_folder_path = os.path.join(folder_path, str(current_month))

    today_file = f"{current_day}.txt"

    if os.path.exists(month_folder_path):
        file_path = os.path.join(month_folder_path, today_file)

        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read()
                
                paragraphs = content.split('\n\n')

                p_lines = paragraphs[0].split('\n')
                emoji = getEmoji( p_lines[4] )

                if clean != 0:
                    emoji = [''] * len(emoji)
                
                p_lines[0] = f"{emoji[0]} {p_lines[0]}"         # –¥–∞—Ç–∞
                p_lines[1] = f"__{p_lines[1]}__"                # –∑–∞–≥–æ–ª–æ–≤–æ–∫
                p_lines[3] = f"_{p_lines[3]}_"                  # —Ü–∏—Ç–∞—Ç–∞
                p_lines[4] = f"{emoji[1]} *{p_lines[4]}*"       # –∏—Å—Ç–æ—á–Ω–∏–∫

                paragraphs[0] = '\n'.join(p_lines)
                paragraphs[2] = paragraphs[2].replace(f"–¢–û–õ–¨–ö–û –°–ï–ì–û–î–ù–Ø:", f"{emoji[0]} *–¢–û–õ–¨–ö–û –°–ï–ì–û–î–ù–Ø:*")

                largest_paragraph = max(paragraphs, key=len)
                lines = largest_paragraph.splitlines()
                formatted_paragraph = '\n' + '\n\n'.join(lines) + '\n'
                paragraphs[paragraphs.index(largest_paragraph)] = formatted_paragraph

                final_content = '\n\n'.join(paragraphs)

                return final_content
        else:
            return f"–§–∞–π–ª –¥–ª—è {current_day} —á–∏—Å–ª–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø–∞–ø–∫–µ –º–µ—Å—è—Ü–∞ {current_month}."
    else:
        return f"–ü–∞–ø–∫–∞ –¥–ª—è –º–µ—Å—è—Ü–∞ {current_month} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –ø–∞–ø–∫–µ 'book'."


def createMessage( text, title, title2 = '' ):
    title = escape_markdown_v2( title[0] ), title[1]
    
    if title2:
        title2 = f"_{title2}_\n\n"
    title2 = escape_markdown_v2( title2 )
        
    return f"*__{title[0]}__* {title[1]}\n\n{title2}{text}"


async def telegramPost( chat_id, message_to_send, title ):
    global attempts
    getTitle = title[0]+ " " +title[1]
    
    try:
        await bot.send_message(chat_id=chat_id, text=message_to_send, parse_mode='MarkdownV2')
        print( f"{getTitle} ‚úÖ \n", flush=True )
    except Exception as e:
        print( f"{getTitle} ‚ùå", flush=True )
        print( "–û—à–∏–±–∫–∞ —Ç–≥:", e, " ‚öôÔ∏è", flush=True )
        print( "–ü–æ—Å—Ç:", message_to_send )
        attempts += 1


def aiRequest( role_system, role_user ):
    global attempts
    
    while True:
        if attempts >= 20:
            print("–ü—Ä–µ–≤—ã—à–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è. –¶–∏–∫–ª –∑–∞–≤–µ—Ä—à–µ–Ω. üíÄüíÄüíÄ", flush=True)
            raise SystemExit    # –∑–∞–≤–µ—Ä—à–∞–µ–º –≤—Å—é –ø—Ä–æ–≥—Ä–∞–º–º—É –ø–æ –∏—Å—Ç–µ—á–µ–Ω–∏—é –ø–æ–ø—ã—Ç–æ–∫
                
        completion = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[ 
                {"role": "system", "content": role_system},
                {"role": "user", "content": role_user}
            ],
        )

        # 1 (–æ—á–∏—Å—Ç–∫–∞ –æ—Ç —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ –≤ –≤—ã–≤–æ–¥–µ) 
        ai_response = escape_system_text( 
            escapeUnderline( completion.choices[0].message.content ), 
            role_system 
        )

        # 2 (–æ—á–∏—Å—Ç–∫–∞ –æ—Ç –∏–µ—Ä–æ–≥–ª–∏—Ñ–æ–≤)
        if has_glyphs(ai_response):
            print("has glyphs. try again... ‚öôÔ∏è", flush=True)
            attempts += 1
            continue

        # 3 (–æ—á–∏—Å—Ç–∫–∞ –æ—Ç –ª–∞—Ç–∏–Ω–∏—Ü—ã)
        if has_latins(ai_response):
            print("has latins. try again... ‚öôÔ∏è", flush=True)
            attempts += 1
            continue

        # 4 (–ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–ª–∏–Ω—É —Å–æ–æ–±—â–µ–Ω–∏—è)
        if len( str(ai_response) ) < 250:
            print("too short response. try again... ‚öôÔ∏è", flush=True)
            attempts += 1
            continue

        ai_response = doReplacements( ai_response )
        return escape_markdown_v2( ai_response, 1 )
        

def getEmoji( source = '–±–∞–∑–æ–≤—ã–π' ):
    massiv = [  ]

    # 0
    month = int( datetime.datetime.now().month )
    day = int( datetime.datetime.now().strftime("%-d") )
    
    emojis = [
        'üéÑ', '‚òÉÔ∏è',            # –∑–∏–º–∞
        '‚òòÔ∏è', 'üå±', 'üå∫',    # –≤–µ—Å–Ω–∞
        'üåû', 'üèñÔ∏è', '‚òÄÔ∏è',    # –ª–µ—Ç–æ
        'üçÉ', 'üçÇ', 'üçÅ',    # –æ—Å–µ–Ω—å
        '‚ùÑÔ∏è'
    ]

    emoji = emojis[ month ]

    if month == 0 and day == 7:
        emoji =  'üéÅ'
    if month == 1 and day == 14:
        emoji =  'üíå'
    if month == 2 and day == 8:
        emoji =  'üå∫'
    if month == 9 and day == 30:
        emoji =  'üëª'
    if month == 9 and day ==31:
        emoji = 'üéÉ'
    if month == 10 and day == 1:
        emoji =  'üíÄ'
    if month == 11 and day == 31:
        emoji =  'üéÖ'

    massiv += [ emoji ]


    # 1
    if '–±–∞–∑–æ–≤—ã–π' in source.lower():
        massiv += [ 'üìò' ]
    else:
        massiv += [ 'üìÑ' ]


    # 2
    emoji = [ 'üìñ', 'üìë', 'üìå', '‚û°Ô∏è', 'üëá', '‚ú®', '‚ö™Ô∏è', 
              '„Ä∞Ô∏è', '‚Ä¢', 'üìö', 'üìì', 'üìï', 'üìó', 'üóÇ', 
              'üìô', 'üóû', 'üì∞', 'üìÑ', 'üìÉ', 'üìë', 'üßæ', 
              'üìä', 'üìà', 'üìâ', 'üóÉ', 'üìÇ' ]

    massiv += [ random.choice( emoji ) ]

    return massiv
    

def checkNAholiday():
    NAholidays = [
        { 'month': 9, 'day': 10, 'text': '''–í —ç—Ç–æ—Ç —Å–∞–º—ã–π –¥–µ–Ω—å, —Ç–æ–ª—å–∫–æ –±–æ–ª–µ–µ 70 –ª–µ—Ç 
        –Ω–∞–∑–∞–¥ 5 –æ–∫—Ç—è–±—Ä—è 1953 –≥–æ–¥–∞ —Å–æ—Å—Ç–æ—è–ª–æ—Å—å —Å–∞–º–æ–µ –ø–µ—Ä–≤–æ–µ —Å–æ–±—Ä–∞–Ω–∏–µ –ê–Ω–æ–Ω–∏–º–Ω—ã—Ö –ù–∞—Ä–∫–æ–º–∞–Ω–æ–≤! ‚≠ê'''   }
    ]
    today = datetime.date.today()
    title = [ '–°–µ–≥–æ–¥–Ω—è –≤ NA –ø—Ä–∞–∑–¥–Ω–∏–∫!', 'üéâ' ]
    
    for NAholiday in NAholidays:
        if NAholidays['month'] == today.month and NAholidays['day] == today.day:
             await telegramPost( channelBook, NAholidays['text'], title )
